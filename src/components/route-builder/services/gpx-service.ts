import type { GeneratedRoute, RouteMetadata, POILocation, LatLng } from '../types';

export class GPXService {
  generateGPX(route: GeneratedRoute, metadata?: RouteMetadata): string {
    const gpxMetadata = metadata || route.metadata;
    
    const gpxHeader = this.generateGPXHeader();
    const gpxMetadataSection = this.generateMetadataSection(route, gpxMetadata);
    const gpxWaypoints = this.generateWaypoints(route.pointsOfInterest);
    const gpxTrack = this.generateTrack(route);
    const gpxFooter = this.generateGPXFooter();

    return [
      gpxHeader,
      gpxMetadataSection,
      gpxWaypoints,
      gpxTrack,
      gpxFooter
    ].join('\n');
  }

  validateGPX(gpxContent: string): boolean {
    try {
      // Basic validation checks
      if (!gpxContent.includes('<?xml')) return false;
      if (!gpxContent.includes('<gpx')) return false;
      if (!gpxContent.includes('</gpx>')) return false;
      
      // Check for required elements
      const hasTrack = gpxContent.includes('<trk>') && gpxContent.includes('</trk>');
      const hasTrackSegment = gpxContent.includes('<trkseg>') && gpxContent.includes('</trkseg>');
      
      if (!hasTrack || !hasTrackSegment) return false;

      // Try to parse as XML (basic check)
      if (typeof DOMParser !== 'undefined') {
        const parser = new DOMParser();
        const doc = parser.parseFromString(gpxContent, 'text/xml');
        const parseError = doc.getElementsByTagName('parsererror');
        return parseError.length === 0;
      }

      return true;
    } catch (error) {
      console.error('GPX validation error:', error);
      return false;
    }
  }

  addWaypoints(gpx: string, pois: POILocation[]): string {
    if (pois.length === 0) return gpx;

    const waypointsXML = this.generateWaypoints(pois);
    
    // Insert waypoints after metadata section
    const metadataEndIndex = gpx.indexOf('</metadata>');
    if (metadataEndIndex !== -1) {
      const insertIndex = metadataEndIndex + '</metadata>'.length;
      return gpx.slice(0, insertIndex) + '\n' + waypointsXML + gpx.slice(insertIndex);
    }

    // If no metadata section, insert after GPX opening tag
    const gpxOpenIndex = gpx.indexOf('>');
    if (gpxOpenIndex !== -1) {
      return gpx.slice(0, gpxOpenIndex + 1) + '\n' + waypointsXML + gpx.slice(gpxOpenIndex + 1);
    }

    return gpx;
  }

  private generateGPXHeader(): string {
    return `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Pedal Peak Route Builder" 
     xmlns="http://www.topografix.com/GPX/1/1"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">`;
  }

  private generateMetadataSection(route: GeneratedRoute, metadata: RouteMetadata): string {
    const creationTime = new Date().toISOString();
    
    return `  <metadata>
    <name>${this.escapeXML(route.name)}</name>
    <desc>${this.escapeXML(route.description || 'Generated by Pedal Peak Route Builder')}</desc>
    <author>
      <name>Pedal Peak Route Builder</name>
      <link href="https://pedal-peak.com">
        <text>Pedal Peak</text>
      </link>
    </author>
    <copyright author="Pedal Peak">
      <year>${new Date().getFullYear()}</year>
      <license>https://pedal-peak.com/terms</license>
    </copyright>
    <time>${creationTime}</time>
    <keywords>cycling,${route.rideType},${route.difficulty}</keywords>
    <bounds minlat="${this.getMinLat(route.path)}" minlon="${this.getMinLng(route.path)}" 
            maxlat="${this.getMaxLat(route.path)}" maxlon="${this.getMaxLng(route.path)}" />
    <extensions>
      <distance>${route.distance}</distance>
      <elevation_gain>${route.elevationGain}</elevation_gain>
      <elevation_loss>${route.elevationLoss}</elevation_loss>
      <estimated_time>${route.estimatedTime}</estimated_time>
      <difficulty>${route.difficulty}</difficulty>
      <ride_type>${route.rideType}</ride_type>
      <surface_paved>${route.surfaceTypes.paved}</surface_paved>
      <surface_gravel>${route.surfaceTypes.gravel}</surface_gravel>
      <surface_trail>${route.surfaceTypes.trail}</surface_trail>
      <generated_by>${metadata.generatedBy}</generated_by>
      <version>${metadata.version}</version>
      <sources>${metadata.sources.join(',')}</sources>
    </extensions>
  </metadata>`;
  }

  private generateWaypoints(pois: POILocation[]): string {
    if (pois.length === 0) return '';

    return pois.map((poi, index) => {
      const arrivalTime = poi.estimatedArrivalTime.toISOString();
      
      return `  <wpt lat="${poi.location.lat}" lon="${poi.location.lng}">
    <name>${this.escapeXML(poi.name)}</name>
    <desc>${this.escapeXML(this.getPOIDescription(poi))}</desc>
    <type>${poi.type}</type>
    <sym>${this.getPOISymbol(poi.type)}</sym>
    <extensions>
      <distance_from_start>${poi.distanceFromStart}</distance_from_start>
      <estimated_arrival>${arrivalTime}</estimated_arrival>
      <is_open>${poi.isOpen}</is_open>
      <poi_type>${poi.type}</poi_type>
      ${poi.contact?.phone ? `<phone>${this.escapeXML(poi.contact.phone)}</phone>` : ''}
      ${poi.contact?.website ? `<website>${this.escapeXML(poi.contact.website)}</website>` : ''}
      ${poi.contact?.address ? `<address>${this.escapeXML(poi.contact.address)}</address>` : ''}
    </extensions>
  </wpt>`;
    }).join('\n');
  }

  private generateTrack(route: GeneratedRoute): string {
    const trackPoints = route.path.map((point, index) => {
      // Add elevation data if available
      const elevation = this.getElevationForPoint(route, index);
      const elevationXML = elevation !== null ? `\n    <ele>${elevation}</ele>` : '';
      
      return `    <trkpt lat="${point.lat}" lon="${point.lng}">${elevationXML}
    </trkpt>`;
    }).join('\n');

    return `  <trk>
    <name>${this.escapeXML(route.name)}</name>
    <desc>${this.escapeXML(route.description || 'Cycling route generated by Pedal Peak')}</desc>
    <type>${route.rideType === 'road' ? 'Road Cycling' : 'Gravel Cycling'}</type>
    <extensions>
      <distance>${route.distance}</distance>
      <elevation_gain>${route.elevationGain}</elevation_gain>
      <difficulty>${route.difficulty}</difficulty>
    </extensions>
    <trkseg>
${trackPoints}
    </trkseg>
  </trk>`;
  }

  private generateGPXFooter(): string {
    return '</gpx>';
  }

  private escapeXML(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }

  private getMinLat(path: LatLng[]): number {
    return Math.min(...path.map(p => p.lat));
  }

  private getMaxLat(path: LatLng[]): number {
    return Math.max(...path.map(p => p.lat));
  }

  private getMinLng(path: LatLng[]): number {
    return Math.min(...path.map(p => p.lng));
  }

  private getMaxLng(path: LatLng[]): number {
    return Math.max(...path.map(p => p.lng));
  }

  private getPOIDescription(poi: POILocation): string {
    const typeLabel = poi.type.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
    const openStatus = poi.isOpen ? 'Open' : 'Closed';
    const arrivalTime = poi.estimatedArrivalTime.toLocaleTimeString([], { 
      hour: '2-digit', 
      minute: '2-digit' 
    });
    
    let description = `${typeLabel} - ${openStatus} at estimated arrival (${arrivalTime})`;
    
    if (poi.contact?.phone) {
      description += `\nPhone: ${poi.contact.phone}`;
    }
    
    if (poi.contact?.address) {
      description += `\nAddress: ${poi.contact.address}`;
    }
    
    return description;
  }

  private getPOISymbol(poiType: string): string {
    const symbolMap: Record<string, string> = {
      'cafe': 'Restaurant',
      'restaurant': 'Restaurant',
      'bakery': 'Restaurant',
      'bike_shop': 'Bike Trail',
      'viewpoint': 'Scenic Area'
    };
    
    return symbolMap[poiType] || 'Waypoint';
  }

  private getElevationForPoint(route: GeneratedRoute, index: number): number | null {
    // If we have elevation profile data, use it
    if (route.metadata && 'elevationProfile' in route.metadata) {
      const elevationProfile = (route.metadata as any).elevationProfile;
      if (elevationProfile && elevationProfile[index]) {
        return elevationProfile[index].elevation;
      }
    }
    
    // Otherwise, estimate elevation based on route characteristics
    if (route.elevationGain > 0 && route.path.length > 1) {
      const progress = index / (route.path.length - 1);
      const baseElevation = 500; // Assume 500m base elevation
      const elevationVariation = Math.sin(progress * Math.PI * 2) * (route.elevationGain / 4);
      return Math.round(baseElevation + elevationVariation);
    }
    
    return null;
  }

  // Utility method to generate filename for GPX download
  generateFilename(route: GeneratedRoute): string {
    const sanitizedName = route.name
      .replace(/[^a-zA-Z0-9\s-]/g, '') // Remove special characters
      .replace(/\s+/g, '-') // Replace spaces with hyphens
      .toLowerCase();
    
    const date = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
    
    return `${sanitizedName}-${date}.gpx`;
  }

  // Method to create downloadable blob
  createDownloadBlob(gpxContent: string): Blob {
    return new Blob([gpxContent], { 
      type: 'application/gpx+xml',
      endings: 'native'
    });
  }

  // Method to trigger download in browser
  downloadGPX(route: GeneratedRoute, metadata?: RouteMetadata): void {
    const gpxContent = this.generateGPX(route, metadata);
    const blob = this.createDownloadBlob(gpxContent);
    const filename = this.generateFilename(route);
    
    // Create download link and trigger download
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  // Method to get GPX as data URL for sharing
  getGPXDataURL(route: GeneratedRoute, metadata?: RouteMetadata): string {
    const gpxContent = this.generateGPX(route, metadata);
    const blob = this.createDownloadBlob(gpxContent);
    return URL.createObjectURL(blob);
  }
}